---
title: "sdp_individual_move_variation_nb"
output: html_document
---

### Individual Variation of Movement

First, load libraries

```{r}
library(tidyverse)
library(som.nn)
library(ape)
```

#### Revise Move Function

Change the potential moves from sampling separate x and y values to sampling pairs, thus the ratios can be modified

```{r}

move_host <- function(hid, hosts, coords, n_moves, inactivity = 1){
  ## grab host
  host_start <- filter(hosts, host_id %in% hid)
  
  ## grab landscape size for torus wrap
  max_x <- max(coords$x)
  max_y <- max(coords$y)
  
  ## set up moves to sample from
  moveset <- tibble(
    x = c(-1, -1, -1, 0, 0, 1, 1, 1, rep(0, inactivity)),
    y = c(-1, 0, 1, -1, 1, -1, 0, 1, rep(0, inactivity))
    )
  
  ## random moves
  moves <- slice_sample(moveset, n = n_moves, replace = TRUE)
  xmoves <- moves$x
  ymoves <- moves$y
  
  ## calculate x positions
  xpos <- cumsum(c(host_start$x, xmoves))
  
  ## calculate y positions
  ypos <- cumsum(c(host_start$y, ymoves))
  
  ## add positions to data
  host_moved <- tibble(host_id = hid,
                       xmove = c(NA, xmoves),
                       ymove = c(NA, ymoves),
                       pre_x = xpos,
                       pre_y = ypos,
                       time = 0:n_moves) %>%
    mutate(oob_x = (pre_x - 1) %/% max_x, ## calc out of bounds
           oob_y = (pre_y - 1) %/% max_y,
           x = pre_x - (max_x * oob_x), ## wrap around torus
           y = pre_y - (max_y * oob_y),
           id = str_c(x, y, sep = "_")) %>% ## generate ids
    left_join(select(coords, id, value), by = "id") %>% ## bring in parasite info
    mutate(parasite_gain = value * rbinom(n = n(), size = 1, prob = 0.5),
           parasite_burden = cumsum(parasite_gain)) ## attach parasites
  
  ## return sim data
  return(host_moved)
}

```

Now test it

```{r}
inactivity = 1
moveset <- tibble(
    x = c(-1, -1, -1, 0, 0, 1, 1, 1, rep(0, inactivity)),
    y = c(-1, 0, 1, -1, 1, -1, 0, 1, rep(0, inactivity))
    )

size <- 12
coords <- tibble(x = rep(1:size, size), 
                   y = rep(1:size, each = size),
                   id = str_c(x, y, sep = "_"),
                   weight = rep(1, size^2), # Weight starts equal for all cells
                   value = rep(0, size^2)) # Cell type starts out as 0 for all

coords$value <- rbinom(n = size^2, size = 1, prob = 0.25)

n_hosts <- 24
host_origins <- slice_sample(coords, n = n_hosts, replace = TRUE)
  
hosts <- host_origins %>%
  select(x, y, id) %>%
  mutate(host_id = seq_len(nrow(host_origins)),
         time = 0)

test_host <- move_host(hid = 1, hosts = hosts, coords = coords, n_moves = 100, inactivity = 10)

test_inactivity <- map_df(1:16, 
                          function(x){
                            dat <- move_host(hid = 1, hosts = hosts, coords = coords,
                                             n_moves = 300, inactivity = x)
                            spaces <- length(levels(factor(dat$id)))
                            return(tibble(inactivity = x, spaces = spaces))
                          })

qplot(x = inactivity, y = spaces, data = test_inactivity)
```

Works great! Increasing "inactivity" make the host move less, visit fewer spaces

#### More Movement Optimization

However, the above function still seems inefficient as it does things one host at a time.

```{r}

size <- 12
coords <- tibble(x = rep(1:size, size), 
                   y = rep(1:size, each = size),
                   id = str_c(x, y, sep = "_"),
                   weight = rep(1, size^2), # Weight starts equal for all cells
                   value = rep(0, size^2)) # Cell type starts out as 0 for all

coords$value <- rbinom(n = size^2, size = 1, prob = 0.25)

n_hosts <- 24
host_origins <- slice_sample(coords, n = n_hosts, replace = TRUE)
n_moves <- 300
  
hosts <- host_origins %>%
  select(x, y, id) %>%
  mutate(host_id = seq_len(nrow(host_origins)),
         inactivity = runif(n_hosts))



## grab landscape size for torus wrap
max_x <- max(coords$x)
max_y <- max(coords$y)
  
## set up moves to sample from
moveset <- tibble(
    move_id = 1:9,
    xmove = rep(c(0, -1, 1), 3),
    ymove = rep(c(0, -1, 1), each = 3)
    )
  
c(1, rep(5, 0))

## random moves


##### THIS IS IT 
hosts_moving <- hosts[rep(1:nrow(hosts), each = n_moves + 1),] %>%
  mutate(time = rep(0:n_moves, n_hosts),
         active = inactivity * sample(1:9, size = n(), replace = TRUE) < 1,
         move_id = sample(2:9, size = n(), replace = TRUE)^active) %>%
  left_join(moveset, by = "move_id") %>%
  mutate(xmove = if_else(time == 0, x, as.integer(xmove)),
         ymove = if_else(time == 0, y, as.integer(ymove))) %>%
  group_by(host_id) %>%
  mutate(pre_x = cumsum(xmove),
         pre_y = cumsum(ymove),
         oob_x = (pre_x - 1) %/% max_x, ## calc out of bounds
         oob_y = (pre_y - 1) %/% max_y,
         x = pre_x - (max_x * oob_x), ## wrap around torus
         y = pre_y - (max_y * oob_y),
         id = str_c(x, y, sep = "_")
         ) %>%
  left_join(select(coords, id, value), by = "id") %>% ## bring in parasite info
  mutate(parasite_gain = value * rbinom(n = n(), size = 1, prob = 0.5),
           parasite_burden = cumsum(parasite_gain)) ## attach parasites
#####
  
length(rep(c(NA, inactivity * sample(1:9, size = n_moves, replace = TRUE) < 1), n_hosts))

(9^FALSE)

1/9 * (1:10)

moves <- sample(c(1:9, rep(5, inactivity - 1)), n = n_moves, replace = TRUE)
xmoves <- moves$x[moves]
ymoves <- moves$y[moves]
  
## calculate x positions
xpos <- cumsum(c(host_start$x, xmoves))
  
## calculate y positions
ypos <- cumsum(c(host_start$y, ymoves))
  
## add positions to data
host_moved <- tibble(host_id = hid,
                       xmove = c(NA, xmoves),
                       ymove = c(NA, ymoves),
                       pre_x = xpos,
                       pre_y = ypos,
                       time = 0:n_moves) %>%
    mutate(oob_x = (pre_x - 1) %/% max_x, ## calc out of bounds
           oob_y = (pre_y - 1) %/% max_y,
           x = pre_x - (max_x * oob_x), ## wrap around torus
           y = pre_y - (max_y * oob_y),
           id = str_c(x, y, sep = "_")) %>% ## generate ids
    left_join(select(coords, id, value), by = "id") %>% ## bring in parasite info
    mutate(parasite_gain = value * rbinom(n = n(), size = 1, prob = 0.5),
           parasite_burden = cumsum(parasite_gain)) ## attach parasites
```

#### Revise Sim Function

Now, allow the simulation function to pass inactivity values
